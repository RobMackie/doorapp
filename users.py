import os
import json
import argparse
import urllib
from passlib.apps import custom_app_context as pwd_context

URL_BASE = 'http://tfi.ev3hub.com'

class Users(object):
    def __init__(self):
        self.userfile_mtime = 0
        self.users = {}
        self.path = 'users.json'
        self.loadIfNewer()

    def updateCheckIn(self):
        keyholders = []
        for name in self.users:
            user = self.users[name]
            keyholders.append(user.get('barcode',''))
        requestStr = URL_BASE + '/admin/updateKeyholders?keyholders='
        for keyholder in keyholders:
            requestStr += keyholder + "%2C"
        requestStr = requestStr[:-3]
        print(f'Request: {requestStr}')
        urllib.request.urlopen(requestStr)

    def __str__(self):
        result = ''
        for user in self.users:
            result += user + '-' + self.users[user]['MAC'] + '\n'
        return result

    def loadIfNewer(self):
        # If we have the most recent
        if os.stat(self.path).st_mtime == self.userfile_mtime:
            return
        try:
            with open(self.path, 'r') as user_file:
                self.users = json.loads(user_file.read())
            self.userfile_mtime = os.stat(self.path).st_mtime
        except IOError:
            pass

    def save(self):
        with open(self.path, 'w') as user_file:
            json.dump(self.users, user_file)
        self.userfile_mtime = os.stat(self.path).st_mtime
        with open("iptables", 'w') as iptable_file:
            self.make_iptable_file(iptable_file)
        self.updateCheckIn()

# if username already exists, this overwrites it.   So be careful upon calling it!
    def add(self, username, mac, password, barcode, admin=False):
        self.loadIfNewer()
        self.users[username] = {}
        self.users[username]['MAC'] = mac
        self.users[username]['password'] = pwd_context.hash(password)
        self.users[username]['admin'] = admin
        self.users[username]['barcode'] = barcode
        self.save()

    def edit(self, username, mac, admin):
        uname = self.get(username)
        self.users[uname]['MAC'] = mac
        self.users[uname]['admin'] = admin
        self.save()

    def remove(self, username):
        uname = self.get(username)
        if uname:
            del self.users[uname]
            self.save()

    def change_password(self, username_in, newpass):
        username = self.get(username_in)
        self.users[username]['password'] = pwd_context.hash(newpass)
        self.save()

    def get(self, username):   # this will return the case version that is in the users list
        self.loadIfNewer()
        if not username:
            return ''  # not found
        lower_username = username.lower()
        for key in self.users:
            if key.lower() == lower_username:
                return key
        return ''   # not found

    def get_users(self):
        self.loadIfNewer()
        return self.users

    def make_iptable_file(self, f):
        self.loadIfNewer()
        f.write("# Generated by Doorapp\n")
        f.write("*filter\n")
        f.write(":INPUT ACCEPT [0:0]\n")
        f.write(":FORWARD ACCEPT [0:0]\n")
#        f.write(":OUTPUT ACCEPT [9:588]\n");
#        f.write("-A OUTPUT -p all -j ACCEPT\n");
        f.write("# Allow loopback\n")
        f.write("-I INPUT 1 -i lo -j ACCEPT\n")
        f.write("# Allow DNS\n")
#        f.write("-A OUTPUT -p udp --dport 53 -j ACCEPT\n");
        f.write("# Allow connections to some outside sites\n")
#        f.write("#-A OUTPUT -p tcp -d ev3hub.com -j ACCEPT\n");
#        f.write("#-A OUTPUT -p tcp -d github.com -j ACCEPT\n");
        f.write("-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n")
        for u in self.users:
            f.write("-A INPUT -m mac --mac-source " +
                    self.users[u]['MAC'] + " -j ACCEPT\n")
        f.write("# -A INPUT -j LOG\n")
        f.write("-A INPUT -j DROP\n")
        f.write("COMMIT\n")

    def get_barcode(self, username_in):
        username = self.get(username_in)
        return self.users[username]['barcode']

    def get_mac(self, username_in):
        username = self.get(username_in)
        return self.users[username]['MAC']

    def get_admin(self, username_in):
        username = self.get(username_in)
        return self.users[username]['admin']

    def verify_password(self, username_in, password):
        username = self.get(username_in)
        if username:
            return pwd_context.verify(password, self.users[username]['password'])
        else:
            return False


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--add', nargs=3, dest='user_add',
                        default=[], help='add user <username> <mac> <barcode>')
    parser.add_argument('--del', nargs=1, dest='user_del',
                        default=[], help='del user <username>')
    parser.add_argument('--out', nargs=1, dest='user_out',
                        default=['iptables'], help='out <filename>')
    results = parser.parse_args()

    users = Users()
    if results.user_add:
        # Adding a new user gives a default password of the mac address
        users.add(results.user_add[0],
                  results.user_add[1],
                  results.user_add[1][-5:],
                  results.user_add[2])
    if results.user_del:
        users.remove(results.user_del[0])
    if results.user_out:
        users.make_iptable_file(open(results.user_out[0], "w"))
        print ("cat " + results.user_out[0] + " | sudo iptables-restore\n")

    print("User list")
    print("=========")
    print(users)
