import os
import json
import argparse
from passlib.apps import custom_app_context as pwd_context

class Users(object):
    def __init__(self):
        self.userfile_mtime = 0;
        self.users = {};
        self.path = 'users.json'
        self.loadIfNewer();
    def __str__(self):
        result = ''
        for user in self.users:
            result +=  user + '-' + self.users[user]['MAC'] + '\n'
        return result
    def loadIfNewer(self):
        # If we have the most recent
        if os.stat(self.path).st_mtime == self.userfile_mtime:
            return
        try:
            with open(self.path, 'r') as user_file:
                self.users = json.loads(user_file.read())
            self.userfile_mtime = os.stat(self.path).st_mtime;
        except:
            pass
    def save(self):
        with open(self.path, 'w') as user_file:
               json.dump(self.users, user_file)
        self.userfile_mtime = os.stat(self.path).st_mtime;

# if username already exists, this overwrites it.   So be careful upon calling it!
    def add(self, username, mac, password):
        self.loadIfNewer();
        self.users[username] = {}
        self.users[username]['MAC'] = mac
        self.users[username]['password'] = pwd_context.hash(password)
        self.users[username]['admin'] = False;
        self.save();
    def remove(self, username):
        uname = self.get(username);
        if uname:
            del self.users[uname];
            self.save()

    def change_password(self, username_in, newpass):
        username = self.get(username_in)
        self.users[username]['password'] = pwd_context.hash(newpass)
        self.save();

    def get(self, username):   # this will return the case version that is in the users list
        self.loadIfNewer();
        if not username:
            return ''  # not found
        lower_username = username.lower()
        for key in self.users:
            if key.lower() == lower_username:
                return key
        return ''   # not found
    def get_users(self):
        self.loadIfNewer();
        return self.users;
    def make_iptable_file(self, f):
        self.loadIfNewer();
        f.write("# Generated by Doorapp\n");
        f.write("*filter\n");
        f.write(":INPUT ACCEPT [0:0]\n");
        f.write(":FORWARD ACCEPT [0:0]\n");
        f.write(":OUTPUT ACCEPT [9:588]\n");
        f.write("-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n");
        for u in self.users:
           f.write("-A INPUT -m mac --mac-source " + self.users[u]['MAC'] + " -j ACCEPT\n");
        f.write("# -A INPUT -j LOG\n");
        f.write("-A INPUT -j DROP\n");
        f.write("COMMIT\n");
    def get_mac(self, username_in):
        username = self.get(username_in)
        return self.users[username]['MAC']
    def verify_password(self, username_in,password):
        username = self.get(username_in)
        if username:
            return pwd_context.verify(password, self.users[username]['password'])
        else:
            return False;

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--add', nargs=2, dest='user_add', default=[], help='add user <username> <mac>')
    parser.add_argument('--del', nargs=1, dest='user_del', default=[], help='del user <username>')
    parser.add_argument('--out', nargs=1, dest='user_out', default=['iptables'], help='out <filename>')
    results = parser.parse_args()

    users = Users();
    if results.user_add:
       # Adding a new user gives a default password of the mac address
       users.add(results.user_add[0], results.user_add[1], results.user_add[1][-5:])
    if results.user_del:
        users.remove(results.user_del[0])
    if results.user_out:
        users.make_iptable_file(open(results.user_out[0],"w"))
        print "cat " + results.user_out[0] + " | sudo iptables-restore\n"

    print "User list"
    print "========="
    print users
